#!/bin/bash

# setback keeps two directories syncronized by creating hardlinked files
# between them. A file can be provided that contains sets of the two
# locations and the files in these to keep syncronized. Generaly the first
# folder is called the backup directory, the second one the deploy
# directory.


# The -s FILE option must be provided to define the settings file to use.
# 
# Without further options the program will print only status information.
# For each file defined in the settings file two letters will be displayed,
# the first for its status in backuo, the second in deploy:
# 
# MM - missing on both folders
# MF - missing in backup, present in deploy
# FM - missing in deploy, present in backup
# FF - Present in both folders and matching
# FX - Present in both folders and different


# The script also accepts the following options:
# 
# -D will deploy the backup files into the deploy directory. The script
# will create a hardlinked file in de deploy directory, from its counterpart
# in the backup directory, for each file it handles.
# 
# -B will update the files in the backup folder. The script will create
# a hardlinked file in the backup directory, from its counterpart in the
# deploy directory, for each file it handles.
# 
# -f by default the script prints the only the relative portion of the
# handled filenames. If -f is provided the full filenames are printed.
# This only applies when using the -D or -B options, since the status
# printout always display only the relative portion of the filename.



########################################
# Default values
########################################

# Options values
settingsFile=''
backupMode='false'
deployMode='false'
fullFileName='false'

# Error codes
error_invalidOptions=1
error_missingSettingsFile=2



########################################
# Options parsing
########################################

params=$(getopt DBfs: $*)
getoptStatus=$?
set -- $params

if [[ $getoptStatus != 0 ]]; then
	echo 'Invalid options' >&2
	exit $error_invalidOptions
fi

for param; do
	case "$param" in
		-s)
			# settings file
			shift
			settingsFile=$1
			shift
			;;
		-D)
			# Force copy from dotfiles to home
			deployMode='true'
			shift
			;;
		-B)
			# Update dotfiles
			backupMode='true'
			shift
			;;
		-f)
			# Update dotfiles
			fullFileName='true'
			shift
			;;
		--)
			shift
			break
			;;
	esac
done

# Options validations before we start

if [[ $settingsFile = '' ]]; then
	echo 'Settings file not provided' >&2
	exit $error_missingSettingsFile
fi

if [[ ! -f $settingsFile ]]; then
	echo "Settings file not found: $settingsFile" >&2
	exit $error_missingSettingsFile
fi

if [[ $deployMode = 'true' && $backupMode = 'true' ]]; then
	echo 'Invalid options: -F and -U cannot be used simultaneously'
	exit $error_invalidOptions
fi



########################################
# Reading the settings file
########################################

backupLocation=''
deployLocation=''
readStage='backupDir' # -> deployDir -> files -> backupDir

IFS=$'\n'
for line in $(cat $settingsFile); do
	
	# Trimming any edge whitespace
	leading="${line%%[![:space:]]*}"
	trailing="${var##*[![:space:]]}"
	line="${line#$leading}"
	line="${line%$trailing}"
	
	firstChar=${line:0:1}
	
	# Checking for empty lines or comments
	if [[ $line = '' ]]; then
		continue
	fi
	if [[ $firstChar = '#' ]]; then
		continue
	fi
	
	# If jumping a block, we ignore everything except a block separator
	if [[ $readStage = 'jumpBlock' && ! $firstChar = '@' ]]; then
		continue
	fi
	
	# Handling block separator
	if [[ $firstChar = '@' ]]; then
		blockMessage="${line#'@'}"
		leading="${blockMessage%%[![:space:]]*}"
		blockMessage="${blockMessage#$leading}"
		echo "Block: $blockMessage"
		readStage='backupDir'
		continue
	fi
	
	# TODO jump block could be handled here, and in the case we just jump
	# everything unless we are already in a block, instead of having the
	# jumpBlock stage
	
	# Parse and check depending on the stage
	case "$readStage" in
		'backupDir')
			if [[ ${line:0:1} = '~' ]]; then
				# Fixing ~ prefix
				line="$HOME${line#'~'}"
			fi
			if [[ -d "$line" ]]; then
				backupLocation="${line%'/'}"
				readStage='deployDir'
				continue
			else
				readStage='jumpBlock'
				echo "Invalid backup location found: $line" >&2
				continue
			fi
			;;
		'deployDir')
			if [[ ${line:0:1} = '~' ]]; then
				# Fixing ~ prefix
				line="$HOME${line#'~'}"
			fi
			if [[ -d "$line" ]]; then
				deployLocation="${line%'/'}"
				readStage='files'
				continue
			else
				readStage='jumpBlock'
				echo "Invalid deploy location found: $line" >&2
				continue
			fi
			;;
		'files')
			# The rest of the logic for files is after the case statement
			;;
	esac
	
########################################
# Status logic
########################################
	
	# If we reached this place we have a file in hands
	simpleFilePath="$line"
	backupFilePath="$backupLocation/$simpleFilePath"
	deployFilePath="$deployLocation/$simpleFilePath"
	
	# Running status mode
	if [[ $deployMode = 'false' && $backupMode = 'false' ]]; then
		backupStatus='M'
		if [[ -f "$backupFilePath" ]]; then
			backupStatus='F'
		fi
		
		deployStatus='M'
		if [[ -f "$deployFilePath" ]]; then
			deployStatus='F'
		fi
		
		# If both files where found
		if [[ $deployStatus = 'F' && $deployStatus = 'F' ]]; then
			# TODO check here that if one file is a symbolic link it will still say true
			# we probably just need to check for symbolic link in the deploy location
			# otherwise the content is not really backed up to git
			if [[ ! "$backupFilePath" -ef "$deployFilePath" ]]; then
				deployStatus='X'
			fi
		fi
		
		echo "$backupStatus$deployStatus $simpleFilePath"
		continue
	fi
	
	
########################################
# File linking
########################################
	
	if [[ $backupMode = 'true' ]]; then
		if [[ -f "$deployFilePath" ]]; then
			if [[ $fullFileName = 'true' ]]; then
				echo "B $backupFilePath"
			else
				echo "B $simpleFilePath"
			fi
			
			ln -f "$deployFilePath" "$backupFilePath"
			
		else
			if [[ $fullFileName = 'true' ]]; then
				echo "M $deployFilePath"
			else
				echo "M $simpleFilePath"
			fi
		fi
		continue
	fi
	
	if [[ $deployMode = 'true' ]]; then
		if [[ -f "$backupFilePath" ]]; then
			if [[ $fullFileName = 'true' ]]; then
				echo "D $deployFilePath"
			else
				echo "D $simpleFilePath"
			fi
			
			ln -f "$backupFilePath" "$deployFilePath"
			
		else
			if [[ $fullFileName = 'true' ]]; then
				echo "M $backupFilePath"
			else
				echo "M $simpleFilePath"
			fi
		fi
		continue
	fi
	
done
unset IFS

