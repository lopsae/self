#!/bin/bash

# dotcheck helps to keep a backup of dotfiles in a given backup folder.

# By default the program reads its settings from the ~/.self_dotcheck file, if
# the file is not pressent and none is provided through the options the
# program halts.

# If the settings file is found the first line read is considered the backup
# folder and the rest is considered a list of dotfiles to consider.

# Without options the program will print only diagnostic information, if the
# dotfiles considered are both present in the backup folder and in home, and if
# they are the same. This information is presented by listing each dotfile
# and the following status:
# First letter is status in home, second in backup
# MM - missing on both places
# MF - missing in home, present in backup
# FM - missing in backup, present in home
# FF - Present and matching
# FX - Present and different

# -F will force the backup dotfiles into the home folder. Each file in the
# home folder will be created as a hard link of the file in the backup folder.

# -u will update the files in the backup folder. Each file in the
# backup folder will be created as a hard link of the file in the home folder.

# -s FILE provides an alternate path for the settings file.



# Error codes
error_invalidOptions=1
error_missingSettingsFile=2
error_invalidBackupLocation=3
error_noDotfiles=4

# Options values
settingsFile=~/.self_dotcheck
updateMode='false'
forceMode='false'

# Options parsing
params=$(getopt Fus: $*)
getoptStatus=$?
set -- $params

if [[ $getoptStatus != 0 ]]; then
	echo 'Invalid options' >&2
	exit $error_invalidOptions
fi

for param; do
	case "$param" in
		-s)
			# settings file
			shift
			settingsFile=$1
			shift
			;;
		-F)
			# Force copy from dotfiles to home
			forceMode='true'
			shift
			;;
		-u)
			# Update dotfiles
			updateMode='true'
			shift
			;;
		--)
			shift
			break
			;;
	esac
done

# Checks for options before we start
if [[ ! -f $settingsFile ]]; then
	echo "Settings file not found: $settingsFile" >&2
	exit $error_missingSettingsFile
fi

if [[ $forceMode = 'true' && $updateMode = 'true' ]]; then
	echo 'Invalid options: -F and -u cannot be used simultaneously'
	exit $error_invalidOptions
fi


# Reading settings
backupLocation=''
dotfiles=()

IFS=$'\n'
for settingsLine in $(cat $settingsFile); do
	
	# Checking for empty lines
	trimmed=$(echo $settingsLine | tr -d [[:space:]])
	if [[ $trimmed = '' ]]; then
		continue
	fi
	
	# Checking for comments
	if [[ ${trimmed:0:1} = '#' ]]; then
		continue
	fi
	
	# First line is always the backup location
	if [[ $backupLocation = '' ]]; then
		backupLocation=$settingsLine
		# Expanding relative paths
		eval backupLocation=$backupLocation
		continue
	fi
	
	# Rest of lines are dotfiles
	dotfiles+=($settingsLine)
done
unset IFS


# Checking for valid settings
if [[ ! -d $backupLocation ]]; then
	echo "Invalid backup location: $backupLocation" >&2
	exit $error_invalidBackupLocation
fi

if [[ ${#dotfiles[@]} -le 0 ]]; then
	echo "No dotfiles found in settings" >&2
	exit $error_noDotfiles
fi


# Checking backup location for ending slash
stringLength=$((${#backupLocation}-1))
lastCharacter=${backupLocation:$stringLength:1}
if [[ $lastCharacter = '/' ]]; then
	backupLocation=${backupLocation:0:$stringLength}
fi


# Running diagnostic mode
if [[ $forceMode = 'false' && $updateMode = 'false' ]]; then
	IFS=$'\n'
	for dotfile in ${dotfiles[@]}; do
		homeDotfile=$HOME/.$dotfile
		backupDotfile=$backupLocation/$dotfile
		
		homeStatus='M'
		if [[ -f $homeDotfile ]]; then
			homeStatus='F'
		fi
		
		backupStatus='M'
		if [[ -f $backupDotfile ]]; then
			backupStatus='F'
		fi
		
		# If both files where found
		if [[ $backupStatus = 'F' && $backupStatus = 'F' ]]; then
			# TODO check here that if one file is a symbolic link it will still say true
			if [[ ! $homeDotfile -ef $backupDotfile ]]; then
				backupStatus='X'
			fi
		fi
		
		echo "$homeStatus$backupStatus $dotfile"
	done
	unset IFS
	
	exit
fi



if [[ $forceMode = 'true' ]]; then
	echo "force mode"
	exit
fi

if [[ $updateMode = 'true' ]]; then
	echo "update mode"
	exit
fi








exit

# Get all files except for the readme
dotfilePath="$HOME/zelf/dotfiles/"
homePath="$HOME/"
dotfileList=$(ls $dotfilePath | grep -v "^readme.md$")

for filename in $dotfileList; do
	dotFilename=$dotfilePath$filename
	homeFilename=$homePath.$filename
	
	if [[ $forceCopy == 'true' ]]; then
		echo "Forcing copy!"
		exit 0
		
		ln -Fv $dotFilename $homeFilename
	else
		if [[ $dotFilename -ef $homeFilename ]]; then
			echo "matched $filename"
		else
			echo "override $filename"
			ln -F $homeFilename $dotFilename
		fi
	fi
done
