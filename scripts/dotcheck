#!/bin/bash

# dotcheck helps to keep a backup of dotfiles in a given backup folder.
# 
# By default the program reads its settings from the ~/.self_dotcheck file,
# if the file is not pressent and none is provided through the options the
# program halts.
# 
# If the settings file is found the first line read is considered the
# backup folder and the rest is considered a list of dotfiles to consider.
# 
# Without options the program will print only status information for each
# dotfile defined in the settings file. For each file two letters will be
# displayed, the forst for its status in home, the second in backup:
# MM - missing on both places
# MF - missing in home, present in backup
# FM - missing in backup, present in home
# FF - Present and matching
# FX - Present and different


# The script accepts the following options:
# 
# -F will force the backup dotfiles into the home folder. Each file in the
# home folder will be created as a hard link of the file in the backup
# folder.
# 
# -u will update the files in the backup folder. Each file in the
# backup folder will be created as a hard link of the file in the home
# folder.
# 
# -s FILE provides an alternate path for the settings file.


# Normal usage for a new machine should be:
# Run it once with the settings file from the backup location. This will
# copy all files from backup to home:
# > dotcheck -F -s ~/self/dotfiles/self_dotcheck
# 
# Afterwards just run it to check status:
# > dotcheck
# 
# To update the backup just in update mode and then save the backup
# > dotcheck -u




# Error codes
error_invalidOptions=1
error_missingSettingsFile=2
error_invalidBackupLocation=3
error_noDotfiles=4

# Options values
settingsFile=~/.self_dotcheck
updateMode='false'
forceMode='false'

# Options parsing
params=$(getopt Fus: $*)
getoptStatus=$?
set -- $params

if [[ $getoptStatus != 0 ]]; then
	echo 'Invalid options' >&2
	exit $error_invalidOptions
fi

for param; do
	case "$param" in
		-s)
			# settings file
			shift
			settingsFile=$1
			shift
			;;
		-F)
			# Force copy from dotfiles to home
			forceMode='true'
			shift
			;;
		-u)
			# Update dotfiles
			updateMode='true'
			shift
			;;
		--)
			shift
			break
			;;
	esac
done

# Checks for options before we start
if [[ ! -f $settingsFile ]]; then
	echo "Settings file not found: $settingsFile" >&2
	exit $error_missingSettingsFile
fi

if [[ $forceMode = 'true' && $updateMode = 'true' ]]; then
	echo 'Invalid options: -F and -u cannot be used simultaneously'
	exit $error_invalidOptions
fi


# Reading settings
backupLocation=''
dotfiles=()

IFS=$'\n'
for settingsLine in $(cat $settingsFile); do
	
	# Checking for empty lines
	trimmed=$(echo $settingsLine | tr -d [[:space:]])
	if [[ $trimmed = '' ]]; then
		continue
	fi
	
	# Checking for comments
	if [[ ${trimmed:0:1} = '#' ]]; then
		continue
	fi
	
	# First line is always the backup location
	if [[ $backupLocation = '' ]]; then
		backupLocation=$settingsLine
		# Expanding relative paths
		eval backupLocation=$backupLocation
		continue
	fi
	
	# Rest of lines are dotfiles
	dotfiles+=($settingsLine)
done
unset IFS


# Checking for valid settings
if [[ ! -d $backupLocation ]]; then
	echo "Invalid backup location: $backupLocation" >&2
	exit $error_invalidBackupLocation
fi

if [[ ${#dotfiles[@]} -le 0 ]]; then
	echo "No dotfiles found in settings" >&2
	exit $error_noDotfiles
fi


# Checking backup location for ending slash
stringLength=$((${#backupLocation}-1))
lastCharacter=${backupLocation:$stringLength:1}
if [[ $lastCharacter = '/' ]]; then
	backupLocation=${backupLocation:0:$stringLength}
fi


# Working with the dotfiles
IFS=$'\n'
for dotfile in ${dotfiles[@]}; do
	homeDotfile=$HOME/.$dotfile
	backupDotfile=$backupLocation/$dotfile
	
	# Running status mode
	if [[ $forceMode = 'false' && $updateMode = 'false' ]]; then
		homeStatus='M'
		if [[ -f $homeDotfile ]]; then
			homeStatus='F'
		fi
		
		backupStatus='M'
		if [[ -f $backupDotfile ]]; then
			backupStatus='F'
		fi
		
		# If both files where found
		if [[ $backupStatus = 'F' && $backupStatus = 'F' ]]; then
			# TODO check here that if one file is a symbolic link it will still say true
			# we probably just need to check for symbolic link in the backup location
			# otherwise the content is not really backed up to git
			if [[ ! $homeDotfile -ef $backupDotfile ]]; then
				backupStatus='X'
			fi
		fi
		
		echo "$homeStatus$backupStatus $dotfile"
		continue
	fi
	
	
	# Running update mode
	if [[ $updateMode = 'true' ]]; then
		if [[ -f $homeDotfile ]]; then
			echo "Updating $backupDotfile"
			ln -f "$homeDotfile" "$backupDotfile"
		else
			echo "Missing $homeDotfile"
		fi
		continue
	fi
	
	
	# Running update mode
	if [[ $forceMode = 'true' ]]; then
		if [[ -f $backupDotfile ]]; then
			echo "Forcing $homeDotfile"
			ln -f "$backupDotfile" "$homeDotfile"
		else
			echo "Missing $backupDotfile"
		fi
		continue
	fi
	
done
unset IFS

